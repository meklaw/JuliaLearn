# переменную инициализирует "а" инициализирует первая нить
# пока она не инициализирована поток 2 будет ждать (выполнять бесконечный цикл)
# как только "а" бедет инициализирована, нить 2 продолжит свою работу
# это парадигма называется Dataflow

# Thread 1:
# global b = false
# global a = rand()
# global b = true

# Thread 2:
# while !b; end
# use(a)

println(@isdefined z) # false
z = 32
println(@isdefined z) # true

# Thread 3:
# while ! @isdefined(a); end
# use(a)
# Тут надо учитывать потенциальную опасность memory unsafe в конкретном языке, 
# когда например значение переменной "a" может непредсказуемо меняться в разных нитях. 
# Обычно для этого применяется паттерн lock(a)/unlock(a), который блокирует возможность 
# изменения некоторой глобальной переменной другими нитями до окончания её использования.

# Dataflow отличается, независимыми корректными вычислениями -- независимо от того, 
# как они распределяются по параллельным процессам.

# есть 3 функции
# 1 возводит Х в квадрат, как только он будет определен
# 2 задаёт переменную Х со значением 9
# 3 программа замрёт на 10 секунд
# в любом случае будет один результат: программа замрет на 10 сек и Х будет рано 81

# вычисления скромны и терпеливы: не посылают сигналы, а ждут, когда активируются нужные им данные.

function foo()
    x = 1
    if x < 1
        println("less than 1")
        println(bar)
    else
        println("greater than or equal to 1")
    end
end

foo() 
# если x = 0
#"less than 1" и "LoadError: UndefVarError: bar not defined"

for i = 1:5
    if @isdefined a
        print(a)
    end
    a = i
end
